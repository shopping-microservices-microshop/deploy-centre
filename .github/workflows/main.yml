# This GitHub Actions workflow automates the creation of a complete
# Kubernetes and GitOps environment on an AWS EC2 instance.
#
# It uses Terraform to provision the infrastructure and then executes
# a series of scripts to configure everything from the runner to Argo CD
# and the monitoring stack.

name: Create GitOps Environment

# Allow this workflow to be triggered manually from the Actions tab in GitHub
on:
  workflow_dispatch:

jobs:
  provision-and-setup:
    name: Provision and Setup Environment
    # This now runs on your self-hosted runner.
    runs-on: self-hosted

    steps:
      # Step 1: Check out the repository
      - name: Checkout Repository
        uses: actions/checkout@v4

      # Step 2: Install Node.js on the runner
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      # Step 3: Configure AWS Credentials
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      # Step 4: Setup Terraform
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.6.0

      # Step 5: Run Terraform with Check-and-Import Logic
      # This is the core step that makes the workflow resilient without an S3 backend.
      - name: Initialize, Import, and Apply Terraform
        id: terraform
        working-directory: ./infra
        run: |
          # Define the name we expect the EC2 instance to have
          INSTANCE_NAME="k8s-master-runner"

          echo "Initializing a fresh Terraform workspace..."
          terraform init

          echo "Checking if EC2 instance '$INSTANCE_NAME' already exists..."
          # Use the AWS CLI to find a running instance with the correct tag
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=$INSTANCE_NAME" "Name=instance-state-name,Values=running,pending" \
            --query "Reservations[].Instances[].InstanceId" \
            --output text)

          # If an instance ID was found, import it into our new state file
          if [ -n "$INSTANCE_ID" ]; then
            echo "Instance found with ID: $INSTANCE_ID. Importing into Terraform state..."
            terraform import aws_instance.k8s_master "$INSTANCE_ID"
          else
            echo "No existing instance found. Terraform will create a new one."
          fi

          echo "Applying Terraform configuration..."
          # Now, apply the configuration. Terraform has a synchronized state and will do the right thing.
          terraform apply -auto-approve \
            -var="runner_token=${{ secrets.RUNNER_TOKEN }}" \
            -var="aws_access_key_id=${{ secrets.AWS_ACCESS_KEY_ID }}" \
            -var="aws_secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            -var="ssh_key_name=your_key_pair_name" # IMPORTANT: Replace with your actual EC2 key pair name

      # Step 6: Output the public IP of the new instance
      - name: Display New Instance IP
        run: |
          echo "âœ… Environment setup has been initiated on the new EC2 instance."
          echo "To monitor the setup process, SSH into the machine and run:"
          echo "tail -f /var/log/cloud-init-output.log"

